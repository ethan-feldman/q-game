from map import GameMap, Tile, Position

PLACE_SCORE = 1
EXTEND_SCORE = 1 # per tile
NUMBER_SHAPES = 6
NUMBER_COLORS = 6 


'''
Returns the score of a turn.
'''
def score_turn(map, action, player_placed_all_tiles, config_s):
    if action.actionString == 'pass':
        return 0
    elif action.actionString == 'exchange':
        return 0
    else:
        placements = action.action()
        return score_placement(map, placements, player_placed_all_tiles, config_s)

def score_placement(map, placements, placed_all, config_s):
    ''' Scores a turn according to the number of tiles placed, if a Q is completed,
    board is extended, and all tiles are placed.

    Arguments:
        map (GameMap): the GameMap after it has been modified with placements.
        placements ((Position, Tile)): the placements that led to that state of the map.
        num_tiles_possessed (int): the number of tiles possessed by the player before the turn.

        Returns:
            Nat: the score that these placements generated by modifying the map.
        '''

    return (score_number_tiles(placements) + 
    score_complete_q(map._tiles, placements, config_s.q_bonus) + 
    score_extend(map._tiles, placements) + 
    score_place_all_tiles(placed_all, config_s.finish_bonus))
    
def score_number_tiles(placements):
    ''' Scores the turn according the number of placements made.
        Arguments:
            placements ((Position, Tile)): placements made on the map.
        Returns:
            Nat: the number of placements made.
        '''
    return len(placements) * PLACE_SCORE


def score_complete_q(tiles, placements, q_bonus):
    '''
        Adds 6 points for each Q completed. A Q is a contiguous sequence of tiles that contains all shapes or all colors and nothing else.
        It then follows that a Q only exists in a line segment of exactly 6 tiles. A full set of colors and shapes are both of size 6.
        Arguments:
        tiles {Position, Tile}: the tiles on the board after the placement is made that is to be scored.
        placements ((Position, Tile)): the placements that must be checked for extending other tiles.
        Returns:
        score (Nat): the score that is returned by checking if a complete Q is made by any of possible placements.
        
    
        Empty Set - representing the positions that have been checked
        
        For each placement:

            Generate the sequences connected to the tile that might contain a Q - separated by the directions they are in

            If said sequences exist, add them to the checked set and add the score

            Conditionals: remove the tile from the checked set --> a Q may exist in the orthogonal direction
            
    '''
    score = 0
    checked_positions = set()

    for position, tile in placements:
        horizontal_set = possible_q_tiles(tiles, (position, tile), Position(1,0))
        vertical_set = possible_q_tiles(tiles, (position, tile), Position(0,1))

        checked_positions, add_score = score_q(tiles, position, horizontal_set, checked_positions, q_bonus)
        score += add_score
        checked_positions, add_score = score_q(tiles, position, vertical_set, checked_positions, q_bonus)
        score += add_score

    return score


'''
Returns a tuple where the first element is the updated set of checked positions and the second element is the score of the checked sequence.
If the sequence was invalid, the c\hecked positions remains the same and the returned score is 0
'''
def score_q(tiles, position, position_set, checked_positions, q_bonus):

    # the current position was apart of a Q already checked, but an additional Q could exist in the orthogonal direction
    if position in checked_positions:
        checked_positions.remove(position)

    if (len(checked_positions.intersection(position_set)) == 0): # checks that all elements of set haven't been scored already 
        # updates position set with the tiles, checks if all colors or shape matches
        return (checked_positions.union(position_set), match_color_or_shape(tiles, position_set, q_bonus))
    
    return (checked_positions, 0) # the set did not contain a Q



def match_color_or_shape(tiles, position_set, q_bonus):
    ''' Workhorse function of scoring a q. Because the length of tile_set is guaranteed to be 6,
    if the size of either shape or color set is also 6, then there must exist a Q with those tiles.
    Arguments:
        tiles {Position, Tile}: the tiles on the board after the placement is made that is to be scored.
        position_set {Position}: Set of 6 tiles to check for all shapes or colors. 
    Returns:
        Nat: the number of points gained for this set of tiles, either 6 or 0.
    '''
    shape_set = set()
    color_set = set()
    for position in position_set:
        shape_set.add(tiles[position]._shape)
        color_set.add(tiles[position]._color)
     
    if (len(shape_set) == NUMBER_SHAPES or len(color_set) == NUMBER_COLORS):
        return q_bonus
    else:
        return 0
    
def possible_q_tiles(tiles, placement, axis):
    '''
    Checks that the line of tiles situated on the same axis of the placement 
    contains exactly 6 tiles. 
    Arguments:
        tiles {Position, Tile}: the tiles on the board after the placement is made that is to be scored.
        placement (Position, Tile): One of the placements containing its position and tile.
        axis (Position): either (1, 0) for horizontal, (0, 1) for vertical.
    Returns:
        set: all 6 candidate positions if a Q is achievable, or an empty set if there are 
        any other amount of positions.
    ''' 
    positions_found = get_connected_tiles(tiles, placement, axis)

    # Currently relies on the number of colors and shapes being the same
    if len(positions_found) == NUMBER_SHAPES:
        return positions_found
    else:
        return set()
    
def get_connected_tiles(tiles, placement, axis):
    '''Computes a set of tiles connected to the placement (Position, Tile) in a given direction. Direction is 
    determined by the axis passed in being either (1, 0) or (0, 1).
    Arguments:
        tiles {Position: Tile}: the tiles on the board after the placement is made that is to be scored.
        placement (Position, Tile): One of the placements containing its position and tile.
        axis (Position): either (1,0 for horizontal, or (0, 1) for vertical.
    Returns: 
        positions_found {}: gets all tiles in a connected sequence along a certain row or column. 
    '''
    positions_found = {placement[0]}

    
    new_position = placement[0]
    # traverses the line in the forward direction
    while(tiles.get(new_position) != None):
        positions_found.add(new_position)
        new_position = new_position + axis
        
    # reset position to the placement tile.
    new_position = placement[0]
    # traverses the line in the backward direction 
    while(tiles.get(new_position) != None):
        positions_found.add(new_position)
        new_position = new_position - axis

    return positions_found

def score_extend(tiles, placements):
    ''' Adds a point per tile in a contiguous sequence of tiles that contains at least one of the newly placed tiles.
    Arguments:
        tiles {Position : Tile}: the tiles on the board after the placement is made that is to be scored.
        placements (Position, Tile): the placements that must be checked for extending other tiles.
    Returns:
        len(full_set): The number of points garnered for extending the map.
    '''
    full_set = set()
    extended_in_both_directions = 0
    for position, tile in placements:
        placement_set, add_for_direction = score_extend_helper(tiles, (position, tile))
        full_set = full_set.union(placement_set) 
        extended_in_both_directions += add_for_direction
        
    return (len(full_set) + extended_in_both_directions) * EXTEND_SCORE

def score_extend_helper(tiles, placement):
    ''' Unions every connected tile in both directions of a given placement into placement_set. Denotes all tiles 
    that should be counted for score extend.
    Arguments:
        tiles {Position, Tile}: the tiles on the board after the placement is made that is to be scored.
        placement (Position, Tile):  One of the placements containing its position and tile.
    Returns:
        placement_set {Position}: a set of positions for which tiles should be counted as extended from placements made.
    '''
    vertical_set = get_connected_tiles(tiles, placement, Position(0, 1))
    horizontal_set = get_connected_tiles(tiles, placement, Position(1, 0))
    extended_in_both_directions = 0

    if len(vertical_set) > 1 and len(horizontal_set) > 1:
        extended_in_both_directions = 1


    placement_set = vertical_set.union(horizontal_set)
    return placement_set, extended_in_both_directions 
    

def score_place_all_tiles(placed_all, finish_bonus):
    ''' Adds 6 points if a player places all tiles in its possession.
    Arguments:
        placements ((Position, Tile)): the placements that led to the state of the map.
        num_tiles_possessed (int): The number of tiles that the player possessed before making its turn.
    Returns:
        Nat: the score for placing all tiles in hand. Either 0 or 6.
    '''
    if (placed_all):
        return finish_bonus
    else: 
        return 0